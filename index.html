<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Maze VR</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script type="importmap">
			{
				"imports": {
				"three": "https://unpkg.com/three/build/three.module.js",
				"three/addons/": "https://unpkg.com/three/examples/jsm/"
				}
			  }
		</script>
		<script type="module" >
			import * as THREE from 'three';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			
			
			/////////////
			import { BoxLineGeometry } from 'three/addons/geometries/BoxLineGeometry.js';
			import { VRButton } from 'three/addons/webxr/VRButton.js';
			import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

			let raycaster
			let controller1, controller2;
			let controllerGrip1, controllerGrip2;

			let room, marker, floor, baseReferenceSpace;

			let INTERSECTION;
			const tempMatrix = new THREE.Matrix4();				
			/////////////


			const scene = new THREE.Scene();
			const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			//camera.position.y = 120;
			//camera.position.z = 0;
			//camera.lookAt(70, 70, 0);
			camera.position.x = 0;
			camera.position.y = 2;
			camera.position.z = 0;
			
			
			/////////////////
			marker = new THREE.Mesh(
					new THREE.CircleGeometry( 0.25, 32 ).rotateX( - Math.PI / 2 ),
					new THREE.MeshBasicMaterial( { color: 0xbcbcbc } )
			);
			scene.add( marker );

			raycaster = new THREE.Raycaster();
			/////////////////


			const renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			// is it ok to set animate here b4 definition?
			//renderer.setAnimationLoop( animate );
			//document.body.appendChild( renderer.domElement );
			
			
			//////////////
			renderer.xr.addEventListener( 'sessionstart', () => baseReferenceSpace = renderer.xr.getReferenceSpace() );
			renderer.xr.enabled = true;
			document.body.appendChild( renderer.domElement );
			document.body.appendChild( VRButton.createButton( renderer ) );
			////////////
			
			
			/////////////
			// controllers

			function onSelectStart() {

				this.userData.isSelecting = true;

			}

			function onSelectEnd() {

				this.userData.isSelecting = false;

				if ( INTERSECTION ) {

					const offsetPosition = { x: - INTERSECTION.x, y: - INTERSECTION.y, z: - INTERSECTION.z, w: 1 };
					const offsetRotation = new THREE.Quaternion();
					const transform = new XRRigidTransform( offsetPosition, offsetRotation );
					const teleportSpaceOffset = baseReferenceSpace.getOffsetReferenceSpace( transform );

					renderer.xr.setReferenceSpace( teleportSpaceOffset );

				}

			}

			controller1 = renderer.xr.getController( 0 );
			controller1.addEventListener( 'selectstart', onSelectStart );
			controller1.addEventListener( 'selectend', onSelectEnd );
			controller1.addEventListener( 'connected', function ( event ) {

				this.add( buildController( event.data ) );

			} );
			controller1.addEventListener( 'disconnected', function () {

				this.remove( this.children[ 0 ] );

			} );
			scene.add( controller1 );

			controller2 = renderer.xr.getController( 1 );
			controller2.addEventListener( 'selectstart', onSelectStart );
			controller2.addEventListener( 'selectend', onSelectEnd );
			controller2.addEventListener( 'connected', function ( event ) {

				this.add( buildController( event.data ) );

			} );
			controller2.addEventListener( 'disconnected', function () {

				this.remove( this.children[ 0 ] );

			} );
			scene.add( controller2 );

			// The XRControllerModelFactory will automatically fetch controller models
			// that match what the user is holding as closely as possible. The models
			// should be attached to the object returned from getControllerGrip in
			// order to match the orientation of the held device.

			const controllerModelFactory = new XRControllerModelFactory();

			controllerGrip1 = renderer.xr.getControllerGrip( 0 );
			controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
			scene.add( controllerGrip1 );

			controllerGrip2 = renderer.xr.getControllerGrip( 1 );
			controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
			scene.add( controllerGrip2 );
			
			function buildController( data ) {

				let geometry, material;

				switch ( data.targetRayMode ) {

					case 'tracked-pointer':

						geometry = new THREE.BufferGeometry();
						geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 1 ], 3 ) );
						geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );

						material = new THREE.LineBasicMaterial( { vertexColors: true, blending: THREE.AdditiveBlending } );

						return new THREE.Line( geometry, material );

					case 'gaze':

						geometry = new THREE.RingGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 );
						material = new THREE.MeshBasicMaterial( { opacity: 0.5, transparent: true } );
						return new THREE.Mesh( geometry, material );

				}

			}
			
			////////////////////////
			
			
			var textureLoader = new THREE.TextureLoader();
			
			//	lights
			const light1 = new THREE.DirectionalLight( 0xffffff, 3 );
			light1.position.set( 200, 200, 0 );
			scene.add( light1 );
			
			
			// instantiate a loader
			const loader = new GLTFLoader().setPath( 'https://valentinainterdonato.github.io/models/' );
			//var color_map, bump_map, specular_map;
			var color_map;
			var mat_column, mat_ceiling, mat_wall, mat_pavement;
			const threeTone = textureLoader.load( 'https://valentinainterdonato.github.io/models/threeTone.jpg' );
			threeTone.minFilter = THREE.NearestFilter;
			threeTone.magFilter = THREE.NearestFilter;
			
			//	set environment materials
			mat_column = new THREE.MeshToonMaterial( { color: 0xff0000, gradientMap:threeTone } );
			mat_ceiling = new THREE.MeshToonMaterial( { color: 0x049EF4, gradientMap:threeTone } );
			mat_wall = new THREE.MeshToonMaterial( { color: 0x00ff00, gradientMap:threeTone } );
			mat_pavement = new THREE.MeshToonMaterial( { color: 0x0000ff, gradientMap:threeTone } );
			
			//load geometries
			loader.load( 'maze_A.gltf', function ( gltf ) {
			
				gltf.scene.traverse( function ( child ) {

							if ( child.isMesh ) {

								var mesh_name = child.name.substring(0,3);
								if(mesh_name=='cap' || mesh_name=='sha' || mesh_name == 'bas'){
								
									child.material = mat_column;
								
								}
								else if (mesh_name == 'cei'){
								
									child.material = mat_ceiling;
								
								}
								else if (mesh_name == 'wal'){
								
									child.material = mat_wall;
								
								}
								else{
								
									child.material = mat_pavement;
								
								}

							}

						} );
				scene.add( gltf.scene );
			
			} );


			function animate() {
			
			
				//////////////////
				
				INTERSECTION = undefined;

				if ( controller1.userData.isSelecting === true ) {

					tempMatrix.identity().extractRotation( controller1.matrixWorld );

					raycaster.ray.origin.setFromMatrixPosition( controller1.matrixWorld );
					raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );

					const intersects = raycaster.intersectObjects( [ floor ] );

					if ( intersects.length > 0 ) {

						INTERSECTION = intersects[ 0 ].point;

					}

				} else if ( controller2.userData.isSelecting === true ) {

					tempMatrix.identity().extractRotation( controller2.matrixWorld );

					raycaster.ray.origin.setFromMatrixPosition( controller2.matrixWorld );
					raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );

					const intersects = raycaster.intersectObjects( [ floor ] );

					if ( intersects.length > 0 ) {

						INTERSECTION = intersects[ 0 ].point;

					}

				}

				if ( INTERSECTION ) marker.position.copy( INTERSECTION );

				marker.visible = INTERSECTION !== undefined;
				
				////////////////


				renderer.render( scene, camera );

			}
			
			// is it better here after definition?
			renderer.setAnimationLoop( animate );
			
		</script>
	</body>
</html>
