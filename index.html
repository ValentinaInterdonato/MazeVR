<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Maze VR</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script type="importmap">
			{
				"imports": {
				"three": "https://unpkg.com/three/build/three.module.js",
				"three/addons/": "https://unpkg.com/three/examples/jsm/"
				}
			  }
		</script>
		<script type="module" >
			import * as THREE from 'three';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			
			
			/////////////
			import { BoxLineGeometry } from 'three/addons/geometries/BoxLineGeometry.js';
			import { VRButton } from 'three/addons/webxr/VRButton.js';
			import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

			let raycaster
			let controller1, controller2;
			let controllerGrip1, controllerGrip2;

			let room, marker, floor, baseReferenceSpace;

			let INTERSECTION;
			const tempMatrix = new THREE.Matrix4();				
			/////////////


			const scene = new THREE.Scene();
			const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			//camera.position.y = 120;
			//camera.position.z = 0;
			//camera.lookAt(70, 70, 0);
			camera.position.x = 0;
			camera.position.y = 2;
			camera.position.z = 0;
			
			
			/////////////////
			marker = new THREE.Mesh(
					new THREE.CircleGeometry( 0.25, 32 ).rotateX( - Math.PI / 2 ),
					new THREE.MeshBasicMaterial( { color: 0xbcbcbc } )
			);
			scene.add( marker );

			raycaster = new THREE.Raycaster();
			/////////////////


			const renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			// is it ok to set animate here b4 definition?
			//renderer.setAnimationLoop( animate );
			//document.body.appendChild( renderer.domElement );
			
			
			//////////////
			renderer.xr.addEventListener( 'sessionstart', () => baseReferenceSpace = renderer.xr.getReferenceSpace() );
			renderer.xr.enabled = true;
			document.body.appendChild( renderer.domElement );
			document.body.appendChild( VRButton.createButton( renderer ) );
			////////////
			
			
			/////////////
			// controllers

			function onSelectStart() {

				this.userData.isSelecting = true;

			}

			function onSelectEnd() {

				this.userData.isSelecting = false;

				if ( INTERSECTION ) {

					const offsetPosition = { x: - INTERSECTION.x, y: - INTERSECTION.y, z: - INTERSECTION.z, w: 1 };
					const offsetRotation = new THREE.Quaternion();
					const transform = new XRRigidTransform( offsetPosition, offsetRotation );
					const teleportSpaceOffset = baseReferenceSpace.getOffsetReferenceSpace( transform );

					renderer.xr.setReferenceSpace( teleportSpaceOffset );

				}

			}

			controller1 = renderer.xr.getController( 0 );
			controller1.addEventListener( 'selectstart', onSelectStart );
			controller1.addEventListener( 'selectend', onSelectEnd );
			controller1.addEventListener( 'connected', function ( event ) {

				this.add( buildController( event.data ) );

			} );
			controller1.addEventListener( 'disconnected', function () {

				this.remove( this.children[ 0 ] );

			} );
			scene.add( controller1 );

			controller2 = renderer.xr.getController( 1 );
			controller2.addEventListener( 'selectstart', onSelectStart );
			controller2.addEventListener( 'selectend', onSelectEnd );
			controller2.addEventListener( 'connected', function ( event ) {

				this.add( buildController( event.data ) );

			} );
			controller2.addEventListener( 'disconnected', function () {

				this.remove( this.children[ 0 ] );

			} );
			scene.add( controller2 );

			// The XRControllerModelFactory will automatically fetch controller models
			// that match what the user is holding as closely as possible. The models
			// should be attached to the object returned from getControllerGrip in
			// order to match the orientation of the held device.

			const controllerModelFactory = new XRControllerModelFactory();

			controllerGrip1 = renderer.xr.getControllerGrip( 0 );
			controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
			scene.add( controllerGrip1 );

			controllerGrip2 = renderer.xr.getControllerGrip( 1 );
			controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
			scene.add( controllerGrip2 );
			
			function buildController( data ) {

				let geometry, material;

				switch ( data.targetRayMode ) {

					case 'tracked-pointer':

						geometry = new THREE.BufferGeometry();
						geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 1 ], 3 ) );
						geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );

						material = new THREE.LineBasicMaterial( { vertexColors: true, blending: THREE.AdditiveBlending } );

						return new THREE.Line( geometry, material );

					case 'gaze':

						geometry = new THREE.RingGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 );
						material = new THREE.MeshBasicMaterial( { opacity: 0.5, transparent: true } );
						return new THREE.Mesh( geometry, material );

				}

			}
			
			////////////////////////
			
			
			var textureLoader = new THREE.TextureLoader();
			
			//	lights
			const amb_light = new THREE.AmbientLight( 0x605050 );
			scene.add( amb_light );
			
			//	stronger light indicating the center of the maze
			
			// light towards floor
			// color, intensity, distance, angle, penumbra, decay
			var spotLightCenter = new THREE.SpotLight( 0xffeedd, 20, 20, 2, 0.7, 0.9);
			spotLightCenter.position.set( 0, 8, 0);
			scene.add( spotLightCenter );
			var lightHelperCenter = new THREE.SpotLightHelper(spotLightCenter);
			//scene.add( lightHelperCenter );
			
			// light towards ceiling
			spotLightCenter = new THREE.SpotLight( 0xff8010, 12, 30, 2, 0.7, 0.9);
			spotLightCenter.position.set( 0, 1, 0);
			spotLightCenter.target.position.set(0, 100, 0);
			scene.add( spotLightCenter );
			lightHelperCenter = new THREE.SpotLightHelper(spotLightCenter);
			//scene.add( lightHelperCenter );

			
			var i, j;
			for ( i = 0; i < 16; i++){
			
				for ( j = 0; j < 16 ; j++){
					
					if( ((i == j) || ((15-i)==j)) && ((((i<6) && (j<6)) || ((i<6) && (j>9))) || (((i>9) && (j<6)) || ((i>9) && (j>9))))){
					
						//var spotLight = new THREE.SpotLight( 0xff9940, 0.3, 200, 2, 1, 2);
						// light towards floor
						// color, intensity, distance, angle, penumbra, decay
						var spotLight = new THREE.SpotLight( 0xff9940, 2, 15, 2.5, 0.7, 0.7);
						spotLight.position.set( i * 10 - 75 , 8, j * 10 - 75);
						spotLight.target.position.set(0,-100,0);
						scene.add( spotLight );
						var lightHelper = new THREE.SpotLightHelper(spotLight);
						//scene.add( lightHelper );
						
						// light towards ceiling
						spotLight = new THREE.SpotLight( 0xff7730, 1, 20, 2.5, 0.9, 0.7);
						spotLight.position.set( i * 10 - 75 , 6, j * 10 - 75);
						spotLight.target.position.set(i * 10 - 75, 100, j * 10 - 75);
						scene.add( spotLight );
						lightHelper = new THREE.SpotLightHelper(spotLight);
						//scene.add( lightHelper );
						
					}
					
					else{
						if((((i%3)==0) && ((i+j)%3 == 0)) && ((i<6)||(i>9)||(j<6)||(j>9))) {
							//var spotLight = new THREE.SpotLight( 0xff9940, 0.3, 200, 2, 1, 2);
							// light towards floor
							// color, intensity, distance, angle, penumbra, decay
							var spotLight = new THREE.SpotLight( 0xffaa60, 4, 25, 2.5, 0.7, 0.7);
							spotLight.position.set( i * 10 - 75 , 10, j * 10 - 75);
							spotLight.target.position.set(0,-100,0);
							scene.add( spotLight );
							lightHelper = new THREE.SpotLightHelper(spotLight);
							//scene.add( lightHelper );
							
							// light towards ceiling
							spotLight = new THREE.SpotLight( 0xff9940, 2, 20, 2.5, 0.9, 0.7);
							spotLight.position.set( i * 10 - 75 , 6, j * 10 - 75);
							spotLight.target.position.set(i * 10 - 75, 100, j * 10 - 75);
							scene.add( spotLight );
							lightHelper = new THREE.SpotLightHelper(spotLight);
							//scene.add( lightHelper );
							
						}
					}
					
				}
				if((i == 5) || (i == 10)){
					//var spotLight = new THREE.SpotLight( 0xff9940, 0.3, 200, 2, 1, 2);
					// light towards floor
					// color, intensity, distance, angle, penumbra, decay
					var spotLight = new THREE.SpotLight( 0xffbb80, 2, 15, 2.5, 0.7, 0.7);
					spotLight.position.set( i * 10 - 75 , 8, 7.5 * 10 - 75);
					spotLight.target.position.set(0,-100,0);
					scene.add( spotLight );
					lightHelper = new THREE.SpotLightHelper(spotLight);
					//scene.add( lightHelper );
					
					// light towards ceiling
					spotLight = new THREE.SpotLight( 0xffaa60, 1.5, 20, 2.5, 0.9, 0.7);
					spotLight.position.set( i * 10 - 75 , 6, 7.5 * 10 - 75);
					spotLight.target.position.set(i * 10 - 75, 100, 7.5 * 10 - 75);
					scene.add( spotLight );
					lightHelper = new THREE.SpotLightHelper(spotLight);
					//scene.add( lightHelper );
					
					//var spotLight = new THREE.SpotLight( 0xff9940, 0.3, 200, 2, 1, 2);
					// color, intensity, distance, angle, penumbra, decay
					var spotLight = new THREE.SpotLight( 0xffbb80, 2, 15, 2.5, 0.7, 0.7);
					spotLight.position.set( 7.5 * 10 - 75 , 10, i * 10 - 75);
					spotLight.target.position.set(7.5 * 10 - 75, -100, i * 10 - 75);
					scene.add( spotLight );
					lightHelper = new THREE.SpotLightHelper(spotLight);
					//scene.add( lightHelper );
					
					// light towards ceiling
					spotLight = new THREE.SpotLight( 0xffaa60, 1.5, 20, 2.5, 0.9, 0.7);
					spotLight.position.set( 7.5 * 10 - 75 , 6, i * 10 - 75);
					spotLight.target.position.set(7.5 * 10 - 75, 100, i * 10 - 75);
					scene.add( spotLight );
					lightHelper = new THREE.SpotLightHelper(spotLight);
					//scene.add( lightHelper );
					
				}
					
			}
			
			
			// instantiate a loader
			const loader = new GLTFLoader().setPath( 'https://valentinainterdonato.github.io/models/' );
			//var color_map, bump_map, specular_map;
			var color_map;
			var mat_column, mat_ceiling, mat_wall, mat_pavement;
			
			//	load environment and textures
			color_map = textureLoader.load('https://valentinainterdonato.github.io/models/column_color.png');
			//bump_map = textureLoader.load('https://valentinainterdonato.github.io/models/column_bump.png');
			//specular_map = textureLoader.load('https://valentinainterdonato.github.io/models/column_specular.png');
			//mat_column = new THREE.MeshPhongMaterial( { map: color_map, 
														//bumpMap: bump_map, bumpScale: 0.02,
														//specularMap: specular_map,
														//shininess: 10} );
			mat_column = new THREE.MeshPhongMaterial( { map: color_map});
														
			color_map = textureLoader.load('https://valentinainterdonato.github.io/models/ceiling_color.png');
			//bump_map = textureLoader.load('https://valentinainterdonato.github.io/models/ceiling_bump.png');
			//specular_map = textureLoader.load('https://valentinainterdonato.github.io/models/ceiling_specular.png');
			//mat_ceiling = new THREE.MeshPhongMaterial( { map: color_map, 
														//bumpMap: bump_map, bumpScale: 0.01,
														//specularMap: specular_map,
														//shininess: 1} );
			mat_ceiling = new THREE.MeshPhongMaterial( { map: color_map});
														
			color_map = textureLoader.load('https://valentinainterdonato.github.io/models/stone_color.png');
			//bump_map = textureLoader.load('https://valentinainterdonato.github.io/models/stone_bump.png');
			//specular_map = textureLoader.load('https://valentinainterdonato.github.io/models/stone_specular.png');
			//mat_wall = new THREE.MeshPhongMaterial( { map: color_map, 
														//bumpMap: bump_map, bumpScale: 0.04,
														//specularMap: specular_map,
														//shininess: 0.5} );
			mat_wall = new THREE.MeshPhongMaterial( { map: color_map});
														
			color_map = textureLoader.load('https://valentinainterdonato.github.io/models/pavement_color.png');
			//bump_map = textureLoader.load('https://valentinainterdonato.github.io/models/pavement_bump.png');
			//specular_map = textureLoader.load('https://valentinainterdonato.github.io/models/pavement_specular.png');
			//mat_pavement = new THREE.MeshPhongMaterial( { map: color_map, 
														//bumpMap: bump_map, bumpScale: 0.04,
														//specularMap: specular_map,
														//shininess: 1} );
			mat_pavement = new THREE.MeshPhongMaterial( { map: color_map});
			
			color_map.repeat.x = 12;
			color_map.repeat.y = 12;
			color_map.wrapS = THREE.RepeatWrapping;
			color_map.wrapT = THREE.RepeatWrapping;
			//bump_map.repeat.x = 12;
			//bump_map.repeat.y = 12;
			//bump_map.wrapS = THREE.RepeatWrapping;
			//bump_map.wrapT = THREE.RepeatWrapping;
			//specular_map.repeat.x = 12;
			//specular_map.repeat.y = 12;
			//specular_map.wrapS = THREE.RepeatWrapping;
			//specular_map.wrapT = THREE.RepeatWrapping;
			
			
			loader.load( 'maze_A.gltf', function ( gltf ) {
			
				gltf.scene.traverse( function ( child ) {

							if ( child.isMesh ) {

								child.receiveShadow = true;
								child.castShadow = true;
								var mesh_name = child.name.substring(0,3);
								if(mesh_name=='cap' || mesh_name=='sha' || mesh_name == 'bas'){
								
									child.material = mat_column;
								
								}
								else if (mesh_name == 'cei'){
								
									child.material = mat_ceiling;
								
								}
								else if (mesh_name == 'wal'){
								
									child.material = mat_wall;
								
								}
								else{
								
									child.material = mat_pavement;
								
								}

							}

						} );
				scene.add( gltf.scene );
			
			} );


			function animate() {
			
			
				//////////////////
				
				INTERSECTION = undefined;

				if ( controller1.userData.isSelecting === true ) {

					tempMatrix.identity().extractRotation( controller1.matrixWorld );

					raycaster.ray.origin.setFromMatrixPosition( controller1.matrixWorld );
					raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );

					const intersects = raycaster.intersectObjects( [ floor ] );

					if ( intersects.length > 0 ) {

						INTERSECTION = intersects[ 0 ].point;

					}

				} else if ( controller2.userData.isSelecting === true ) {

					tempMatrix.identity().extractRotation( controller2.matrixWorld );

					raycaster.ray.origin.setFromMatrixPosition( controller2.matrixWorld );
					raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );

					const intersects = raycaster.intersectObjects( [ floor ] );

					if ( intersects.length > 0 ) {

						INTERSECTION = intersects[ 0 ].point;

					}

				}

				if ( INTERSECTION ) marker.position.copy( INTERSECTION );

				marker.visible = INTERSECTION !== undefined;
				
				////////////////


				renderer.render( scene, camera );

			}
			
			// is it better here after definition?
			renderer.setAnimationLoop( animate );
			
		</script>
	</body>
</html>
